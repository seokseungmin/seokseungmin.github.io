---
layout: single
title:  "메서드"
excerpt: "메서드"

categories: Java
tags:  Java

permalink: /categories/메서드/ # url

toc: true
toc_sticky: true

date: 2023-12-29
last_modified_at: 2023-12-30
---

# 메서드
메서드도 변수와 같이 선언 및 정의 후 필요시에 호출해서 사용한다.

# 메서드 선언 및 정의 

```
(접근자)public (반환형)void (메서드 이름)getInfo(매개변수){
                      //메서드 정의
                      System.out.println("i = " + i);
                      System.out.println("b = " + b);
                      System.out.println("d = " + d);
                      System.out.println("c = " + c);
                      System.out.println("s = " + s);
                  }
```

# 메서드 호출 

```java
ChildClass childClass = new ChildClass();
childClass.getInfo();
```

```java
public class ChildClass {
	
	public String name;
	public String gender;
	public int age;
	
	public ChildClass() {
		System.out.println("--ChildClass Constructor--");
	}
	
	public void getInfo() {
		System.out.println("--getInfo() Start--");
		
		System.out.println("name : " + name);
		System.out.println("gender : " + gender);
		System.out.println("age : " + age);
		
	}
}
```

```java
public class MainClass {
	public static void main(String[] args) {
		
		ChildClass child1 = new ChildClass();
		child1.name = "hong gil dong";
		child1.gender = "M";
		child1.age =20;
		
		child1.getInfo();
	}
}
```
    --ChildClass Constructor--
    --getInfo() Start--
    name : hong gil dong
    gender : M
    age : 20

# 매개변수(parameter)
메서드를 호출할 때 데이터를 전달할 수 있다.

```java
public class ChildClass {
	
	public String name;
	public String gender;
	public int age;
	
	public ChildClass() {
		System.out.println("--ChildClass Constructor--");
	}
	
	public void setInfo(String n, String g, int a) {
		System.out.println("--setInfo() START--");
		name = n;
		gender = g;
		age = a;
	}
	
	public void getInfo() {
		System.out.println("--getInfo() START--");
		
		System.out.println("name : " + name);
		System.out.println("gender : " + gender);
		System.out.println("age : " + age);
		
	}
}
```

```java
public class MainClass {
	public static void main(String[] args) {
		
		ChildClass child1 = new ChildClass();
		
		child1.setInfo("Hong gil dong", "M", 20);
		
		child1.getInfo();
	}
}
```
    --ChildClass Constructor--
    --setInfo() START--
    --getInfo() START--
    name : Hong gil dong
    gender : M
    age : 20

# 중복메서드(Overloading)
이름은 같고, 매개변수의 개수 또는 타입이 다른 메서드를 만들 수 있다.

```java
  public void getInfo() {
  		System.out.println("--getInfo - 1 --");
  	}
	
	public void getInfo(int x, int y) {
		System.out.println("--getInfo - 2 --");
		System.out.printf("parameter --> x : %d, y : %d\n", x, y);
	}
	
	public void getInfo(String s1, String s2) {
		System.out.println("--getInfo - 3 --");
		System.out.printf("parameter --> s1 : %s, s2 : %s\n", s1, s2);
	}
```

# 접근자
메서드를 호출할 때 접근자에 따라서 호출이 불가할 수 있다.
private 현재 클래스에서 호출가능!

```java
public class ChildClass {
	
	public String name;
	public String gender;
	public int age;
	
	public ChildClass() {
		System.out.println("--ChildClass Constructor--");
	}
	
	public void setInfo(String n, String g, int a) {
		System.out.println("--setInfo() START--");
		name = n;
		gender = g;
		age = a;
	}
	
	public void getInfo() {
		System.out.println("--getInfo() START--");
		
		System.out.println("name : " + name);
		System.out.println("gender : " + gender);
		System.out.println("age : " + age);
		
		mySecret();
	}
	
	private void mySecret() {
		System.out.println("-- mySecret() --");
	}
}
```

억지로 private 호출하면 The method mySecret() from the type ChildClass is not visible 오류 발생!

```java
public class MainClass {
	public static void main(String[] args) {
		
		ChildClass child1 = new ChildClass();
		
		child1.setInfo("Hong gil dong", "M", 20);
		
		child1.getInfo();
		
		child1.mySecret();
	}
}
```
     The method mySecret() from the type ChildClass is not visible
