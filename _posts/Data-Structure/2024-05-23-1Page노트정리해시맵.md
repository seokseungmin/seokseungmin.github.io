---
title: "1Page 노트정리 해시맵"
excerpt: "[자료구조] 해시맵"

categories:
  - Data Structure
tags:
  - [Data Structure]

permalink: /categories/1Page노트정리해시맵/ # url

toc: true
toc_sticky: true

date: 2024-05-23
last_modified_at: 2024-05-23
---

## 1 Page 노트 정리

![new repo](/assets/images/posts_img/Data-Structure/HashMap.jpg)

## Hash와 Map 개념

### Hash
- **해시(Hash)**: 입력 데이터를 고정된 길이의 데이터로 변환한 값을 말합니다. 이를 해시 값, 해시 코드, 체크섬이라고도 부릅니다.
- **해시 함수(Hash Function)**: 임의의 크기를 가진 입력 데이터를 고정된 크기의 데이터로 변환하는 함수입니다. 주로 데이터 검색과 저장을 효율적으로 하기 위해 사용됩니다.

### Map
- **맵(Map)**: 키-값 쌍을 저장하는 추상 자료형(ADT, Abstract Data Type)입니다. 각 키는 유일하며 중복될 수 없습니다. 그러나 값은 중복될 수 있습니다.
- **다른 이름**: 맵은 연관 배열(Associative array) 또는 딕셔너리(Dictionary)라고도 불립니다.
- **사용 사례**: 키 값에 대응하는 값을 찾거나 매핑하고 싶을 때 사용합니다. 예를 들어, 영화의 제목을 키로, 평점을 값으로 저장하여 특정 영화의 평점을 빠르게 찾을 수 있습니다.

## HashMap이란?
- **정의**: `HashMap`은 Java의 `Map` 인터페이스를 구현한 컬렉션 클래스로, 키-값 쌍을 저장합니다.
- **특징**:
  - 삽입, 삭제, 조회 연산의 평균 시간 복잡도는 O(1)입니다.
  - 키의 중복을 허용하지 않습니다.
  - 입력된 데이터의 순서를 보장하지 않습니다.
  - 동기화를 지원하지 않아 `Thread-unsafe`합니다.

### HashMap과 HashTable 비교
- **HashMap**: 비동기화로 인해 빠르지만 `Thread-safe`하지 않습니다.
- **HashTable**: 동기화되어 `Thread-safe`하지만 상대적으로 느립니다.

## HashMap의 동작 원리

### 기본 원리
- **해싱**: 해시 함수를 사용하여 데이터를 고정된 크기의 해시 값으로 변환합니다.
- **버킷**: 해시 값을 인덱스로 사용하여 데이터(키-값 쌍)를 저장합니다.

### 해시 충돌
- **해시 충돌**: 서로 다른 키가 동일한 해시 값을 가질 때 발생합니다.
- **해결 방법**:
  - **Separate Chaining**: 충돌이 발생한 인덱스에서 연결 리스트를 사용하여 여러 항목을 저장합니다.
  - **Open Addressing**: 충돌이 발생하면 다른 빈 인덱스를 찾아 저장합니다. 대표적으로 **Linear Probing** 방법이 있습니다.
 
Open Addressing은 해시 충돌을 해결하기 위한 방법 중 하나로, 충돌이 발생했을 때 다른 빈 슬롯을 찾아 데이터를 저장하는 방식입니다. 
Open Addressing의 주요 기법에는 Linear Probing, Quadratic Probing, 그리고 Double Hashing이 있습니다. 각각의 기법을 자세히 설명해 보겠습니다.

### 1. Linear Probing

**Linear Probing**은 충돌이 발생했을 때, 고정된 간격(보통 1)으로 다음 슬롯을 순차적으로 탐색하여 빈 슬롯을 찾는 방법입니다.

- **탐색 과정**:
  1. 충돌이 발생한 인덱스 i에서 시작합니다.
  2. 인덱스 (i + 1) % 테이블 크기, (i + 2) % 테이블 크기, ... 식으로 다음 슬롯을 탐색합니다.
  3. 빈 슬롯을 찾거나 원래 슬롯으로 돌아올 때까지 탐색을 계속합니다.

**장점**:
- 구현이 간단합니다.
- 클러스터링 현상이 발생할 수 있습니다(인접한 슬롯들이 연속적으로 채워지기 시작하면, 충돌이 더 빈번해질 수 있음).

**예시**:

```java
// 해시 함수: hash(key) = key % table_size
int index = (hash(key) + i) % table_size; // i는 0부터 시작하는 정수
```

### 2. Quadratic Probing

**Quadratic Probing**은 충돌이 발생했을 때, 일정한 간격이 아닌 점차적으로 증가하는 간격을 사용하여 빈 슬롯을 찾는 방법입니다.

- **탐색 과정**:
  1. 충돌이 발생한 인덱스 i에서 시작합니다.
  2. 인덱스 (i + 1^2) % 테이블 크기, (i + 2^2) % 테이블 크기, (i + 3^2) % 테이블 크기, ... 식으로 다음 슬롯을 탐색합니다.
  3. 빈 슬롯을 찾거나 원래 슬롯으로 돌아올 때까지 탐색을 계속합니다.

**장점**:
- 클러스터링 문제를 완화할 수 있습니다.
- 2차 클러스터링 문제가 발생할 수 있습니다(간격이 제곱수로 증가하므로, 특정 패턴으로 충돌이 발생할 수 있음).

**예시**:

```java
// 해시 함수: hash(key) = key % table_size
int index = (hash(key) + i * i) % table_size; // i는 0부터 시작하는 정수
```

### 3. Double Hashing

**Double Hashing**은 두 개의 해시 함수를 사용하여 충돌이 발생할 때마다 다른 해시 함수를 적용해 새로운 인덱스를 찾는 방법입니다.

- **탐색 과정**:
  1. 첫 번째 해시 함수 h1(key)로 인덱스 i를 계산합니다.
  2. 충돌이 발생하면, 두 번째 해시 함수 h2(key)를 사용하여 이동할 간격을 결정합니다.
  3. 인덱스 (i + j * h2(key)) % 테이블 크기 (j는 0부터 시작하는 정수)로 빈 슬롯을 탐색합니다.

**장점**:
- 클러스터링 문제를 효과적으로 줄일 수 있습니다.
- 충돌 해결을 위한 탐색 패턴이 다양해져 충돌을 줄일 수 있습니다.

**예시**:

```java
// 해시 함수: h1(key) = key % table_size
// 두 번째 해시 함수: h2(key) = prime_number - (key % prime_number)
int index = (h1(key) + j * h2(key)) % table_size; // j는 0부터 시작하는 정수
```

### 표로 정리

| 기법              | 탐색 방식                              | 장점                             | 단점                            |
|-------------------|----------------------------------------|----------------------------------|---------------------------------|
| Linear Probing    | 고정된 간격으로 다음 슬롯 순차 탐색    | 구현이 간단                      | 클러스터링 문제                 |
| Quadratic Probing | 점차적으로 증가하는 간격으로 슬롯 탐색 | 클러스터링 문제 완화             | 2차 클러스터링 문제 발생 가능   |
| Double Hashing    | 두 번째 해시 함수로 간격 결정          | 클러스터링 문제 최소화           | 구현이 복잡                     |

### 결론
Open Addressing의 각 기법은 해시 충돌을 해결하는 데 고유한 장단점을 가지고 있습니다. <br>
Linear Probing은 가장 간단하지만 클러스터링 문제가 있습니다.<br>
Quadratic Probing은 클러스터링 문제를 줄이지만 2차 클러스터링이 발생할 수 있습니다.<br>
Double Hashing은 클러스터링 문제를 최소화하지만 구현이 복잡합니다.<br>
해시 테이블의 특성과 사용 용도에 따라 적절한 기법을 선택하는 것이 중요합니다.<br>

## HashMap 사용법

### 주요 메서드
1. **`V get(Object key)`**: 키에 대응하는 값을 반환합니다. 키가 존재하지 않으면 `null`을 반환합니다.
2. **`V getOrDefault(Object key, V defaultValue)`**: 지정된 키가 존재하면 해당 값을, 그렇지 않으면 기본 값을 반환합니다.
3. **`V put(K key, V value)`**: 키-값 쌍을 추가합니다.
4. **`V remove(Object key)`**: 지정된 키에 대응하는 항목을 제거합니다.
5. **`void clear()`**: 모든 항목을 제거합니다.
6. **`boolean containsKey(Object key)`**: 키가 존재하는지 확인합니다.
7. **`boolean containsValue(Object value)`**: 값이 존재하는지 확인합니다.
8. **`boolean isEmpty()`**: 맵이 비어 있는지 확인합니다.
9. **`Set<K> keySet()`**: 모든 키를 포함하는 `Set`을 반환합니다.
10. **`V replace(K key, V value)`**: 지정된 키에 대응하는 값을 새로운 값으로 대체합니다.

### 예제 코드
```java
import java.util.HashMap;

public class HashMapExample {
    public static void main(String[] args) {
        HashMap<String, String> hashMap = new HashMap<>();
        
        // 데이터 삽입
        hashMap.put("혹성탈출", "9.22");
        
        // 데이터 조회
        System.out.println(hashMap.get("혹성탈출")); // 출력: "9.22"
        System.out.println(hashMap.getOrDefault("범죄도시4", "0")); // 출력: "0"
        
        // 전체 키 조회
        for (String key : hashMap.keySet()) {
            System.out.println(key + ": " + hashMap.get(key));
        }
        
        // 키와 값의 존재 여부 확인
        System.out.println(hashMap.containsKey("혹성탈출")); // true
        System.out.println(hashMap.containsKey("범죄도시4")); // false
        System.out.println(hashMap.containsValue("9.22")); // true
        System.out.println(hashMap.containsValue("10")); // false
    }
}
```

### 표로 정리

| 메서드 | 설명 | 시간 복잡도 |
|--------|------|-------------|
| `get(Object key)` | 키에 대응하는 값을 반환 | O(1) |
| `getOrDefault(Object key, V defaultValue)` | 키가 없으면 기본 값 반환 | O(1) |
| `put(K key, V value)` | 키-값 쌍을 추가 | O(1) |
| `remove(Object key)` | 키에 대응하는 항목 제거 | O(1) |
| `clear()` | 모든 항목 제거 | O(1) |
| `containsKey(Object key)` | 키 존재 여부 확인 | O(1) |
| `containsValue(Object value)` | 값 존재 여부 확인 | O(N) |
| `isEmpty()` | 맵이 비어 있는지 확인 | O(1) |
| `keySet()` | 모든 키를 포함하는 Set 반환 | O(1) |
| `replace(K key, V value)` | 키에 대응하는 값을 대체 | O(1) |

## 결론
`HashMap`은 키-값 쌍을 효율적으로 관리할 수 있는 강력한 자료구조입니다.
해시 함수와 해시 테이블을 이용해 빠른 데이터 검색, 삽입, 삭제가 가능하며, 다양한 상황에서 유용하게 사용할 수 있습니다.
해시 충돌 해결 방법과 동작 원리를 이해하면 `HashMap`을 더욱 효과적으로 활용할 수 있습니다.


알겠습니다. 숫자를 표기할 때 그대로 표기하겠습니다.

# 해시 해킹 성공

## 문제 설명

그린닷컴의 운영자 연두는 비밀번호를 평문 그대로 저장하는 과오를 뒤로하고, 이제부터 암호에 해시 함수를 적용해 저장하려고 한다.<br>
연두가 아는 해시 함수라고는 알고리즘 문제 풀이에 많이 사용되는 롤링 해시 함수밖에 없기 때문에 이것을 응용하여 사용하기로 했다.<br>
그린닷컴의 비밀번호 규칙은 꽤 특이한데, 길이가 정확히 \(N\)이어야 하며, 비밀번호를 이루는 문자는 지정된 \(M\)개의 문자 중 하나여야 한다. <br>
따라서, 사용 가능한 각 문자를 0부터 차례대로 정수에 대응시키면, 비밀번호를 길이가 \(N\)이고 모든 원소가 0 이상 \(M-1\) 이하인 배열 \(P = [P_0, P_1, \dots, P_{N-1}]\)로 나타낼 수 있다.<br>
이렇게 비밀번호를 배열 \(P\)로 나타낸 후, 미리 정해진 정수 \(A\)를 이용하여 다음과 같은 해시 함수 \(h\)를 적용한다.<br>
\[ h(P) = (P_0 \cdot A^0 + P_1 \cdot A^1 + ... + P_{N-1} \cdot A^{N-1}) \mod M \]<br>
예를 들어 배열 \(P = [10, 30, 20], A = 7, M = 55\)인 경우를 생각해보자. 이 경우<br>
\[ h(P) = (10 \cdot 7^0 + 30 \cdot 7^1 + 20 \cdot 7^2) \mod 55 = (10 + 210 + 980) \mod 55 = 45 \]이다. <br>
여기서 \(\bmod\)는 나머지 연산으로 \(1200 = 21 \cdot 55 + 45\)이므로 \(1200 \mod 55 = 45\)이다. <br>
따라서 해시값은 항상 0 이상 \(M-1\) 이하의 정수이다.<br>
그린닷컴 관리자 계정의 비밀번호 해시값을 해킹한 재현이는, 이 해시값으로 실제 비밀번호가 뭐였는지 역추적해보려고 한다. <br>
하지만 그린닷컴에서 사용 가능한 비밀번호는 \(M^N\)개나 있고, 이 중 과연 알아낸 해시값과 일치하는 비밀번호는 몇 개나 될지 궁금해졌다. <br>
여러분이 이것을 대신 구해주자.<br>

## 입력

첫째 줄에 비밀번호의 길이 \(N\)과 문자 종류의 개수 \(M\), 정수 \(A\)가 주어진다. (\(1 \le N, M, A \le 5,000,000\))<br>
둘째 줄에 재현이가 알아낸 해시값 정수 \(H\)가 주어진다. (\(0 \le H < M\))<br>

## 출력

주어진 해시값을 갖는 비밀번호의 개수를 출력한다.<br>
출력하는 값이 너무 커질 수 있으므로, 이것을 \(1,000,000,007\) (=\(10^9 + 7\))로 나눈 나머지를 출력한다.<br>

## 예제 입력 1

```plaintext
3 2 1
1
```

## 예제 출력 1

```plaintext
4
```

\( h([P_0, P_1, P_2]) = (P_0 \cdot 1^0 + P_1 \cdot 1^1 + P_2 \cdot 1^2) \mod 2 = (P_0 + P_1 + P_2) \mod 2 \)이다. 따라서 가능한 모든 비밀번호의 해시값은 다음과 같다.

- \( h([0, 0, 0]) = 0 \)
- \( h([0, 0, 1]) = 1 \)
- \( h([0, 1, 0]) = 1 \)
- \( h([0, 1, 1]) = 0 \)
- \( h([1, 0, 0]) = 1 \)
- \( h([1, 0, 1]) = 0 \)
- \( h([1, 1, 0]) = 0 \)
- \( h([1, 1, 1]) = 1 \)

## 예제 입력 2

```plaintext
5000000 5000000 5000000
1
```

## 예제 출력 2

```plaintext
73352076
```

### 해시 함수와 모듈러 연산을 이용한 조합 개수 계산

해시 값을 H, 배열의 원소를 P, 곱해지는 숫자를 A, mod 연산할 수를 M이라고 정의합니다. 주어진 해시 함수는 다음과 같습니다:

H=(P 
0
​
 ×A 
0
 +P 
1
​
 ×A 
1
 +…+P 
n−1
​
 ×A 
n−1
 )modM

모듈러 연산을 M으로 하기 때문에 해시값은 0부터 (M-1) 사이의 값이 됩니다. 
P 배열을 어떤 수로 조합하더라도 결과는 0부터 (M-1) 사이의 값이 됩니다. 
P는 0부터 (M-1) 사이의 값을 가지며, P는 n개의 원소로 구성되므로 가능한 조합의 수는 \( M^n \)이 됩니다.

### 조합 개수 계산
해시값 H가 가질 수 있는 P 배열의 조합 개수는 다음과 같습니다:
M 
n−1

### 코드 설명
모든 수를 입력받고 \( M^{N-1} \)을 계산하기 위해 반복문을 작성합니다. 
문제에서 배열의 조합 개수가 너무 많을 경우를 대비해 1000000007로 나눈 값을 반환합니다.
\( M^{N-1} \)의 수가 너무 클 경우 long 자료형에 다 담지 못할 것을 대비해 M을 곱할 때마다 1000000007로 나누어줍니다. 
그리고 마지막에 한 번 더 1000000007로 나누어 정답을 반환합니다.

모듈로 연산의 곱셈 법칙을 이용한 연산: (A×B)modC=((AmodC)×(BmodC))modC

### 코드
```java
import java.util.Scanner;

public class Main {
    public static void solution(int n, int m){
        long result = 1;
        for(int i = 0; i < n-1; i++){
            result = (result * m) % 1000000007;
        }
        long answer = result % 1000000007;
        System.out.println(answer);
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        solution(n, m);
    }
}
```

### 요약
- 해시 함수의 정의와 그에 따른 해시 값 계산.
- 모듈로 연산의 곱셈 법칙을 이용하여 큰 수를 다루기 위한 방법.
- Java 코드를 통해 \( M^{N-1} \) 값을 계산하고 1000000007로 나누어 반환하는 과정.

출처 : 백준, https://www.acmicpc.net/problem/26008

