---
title: "그리디 알고리즘"
excerpt: "[알고리즘] 그리디 알고리즘"

categories:
  - Algorithm
tags:
  - [Algorithm]

permalink: /categories/그리디알고리즘/ # url

toc: true
toc_sticky: true

date: 2024-06-07
last_modified_at: 2024-06-07
---

## 그리디 알고리즘 (Greedy Algorithm)
매 순간 현재 기준으로 최선의 답을 선택해 나가는 기법<br>
빠르게 근사치를 계산할 수 있다.<br>
결과적으로는 최적해가 아닐 수도 있다.<br>


## 그리디 알고리즘 예시_1 (1)
Activity Selection Problem<br>
N 개의 활동과 각 활동의 시작/종료 시간이 주어졌을 때, 한 사람이 최대한 많이 할 수 있는 활동의 수 구하기<br>

![new repo](/assets/images/posts_img/Algorithm/img21.PNG)

## 그리디 알고리즘 예시_1 (2)
Activity Selection Problem<br>
종료 시간 기준으로 정렬→ 먼저 종료되는 활동 순, 겹치지 않는 순으로 선택<br>

![new repo](/assets/images/posts_img/Algorithm/img22.PNG)

## 그리디 알고리즘 예시_2 (1)
거스름돈 (동전의 개수 가장 적게)<br>
잔돈: 890<br>
동전 종류: 10, 50, 100, 500<br>
큰 동전부터 계산<br>

![new repo](/assets/images/posts_img/Algorithm/img23.PNG)

## 그리디 알고리즘 예시_2 (2)
거스름돈 (동전의 개수 가장 적게)<br>
잔돈: 890<br>
동전 종류: 10, 50, 100, 400, 500<br>
큰 동전부터 계산<br>

![new repo](/assets/images/posts_img/Algorithm/img24.PNG)

## 그리디 알고리즘 적용 조건
그리디 알고리즘은 빠르지만 최적해를 보장하지는 못함<br>
하기 두 가지 조건에 해당하는 경우 적용 가능<br>
탐욕적 선택 특성 (Greedy choice property)<br>
지금 선택이 다음 선택에 영향을 주지 않음<br>
최적 부분 구조 (Optimal substructure)<br>
전체 문제의 최적해는 부분 문제의 최적해로 이루어짐<br>

### 알고리즘 - 그리디 알고리즘

```java
// 알고리즘 - 그리디 알고리즘
// Activity Selection Problem

import java.util.ArrayList;
import java.util.Collections;

class Activity {
    String name;
    int start;
    int end;

    public Activity(String name, int start, int end) {
        this.name = name;
        this.start = start;
        this.end = end;
    }
}

public class Main {
    public static void selectActivity(ArrayList<Activity> list) {
        // 종료시간 기준 오름차순 정렬
        Collections.sort(list, (x1, x2) -> x1.end - x2.end);

        int curTime = 0;
        ArrayList<Activity> result = new ArrayList<>();
        for (Activity item: list) {
            // 활동의 시작 시간이 현재 시간보다 작으면 추가
            if (curTime <= item.start) {
                // 다음 활동 시간 비교를 위해 현재 활동의 종료 시간으로 업데이트
                curTime = item.end;
                result.add(item);
            }
        }
        
        // 출력
        for (Activity item: result) {
            System.out.print(item.name + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Test code
        ArrayList<Activity> list = new ArrayList<>();
        list.add(new Activity("A", 1, 5));
        list.add(new Activity("B", 4, 5));
        list.add(new Activity("C", 2, 3));
        list.add(new Activity("D", 4, 7));
        list.add(new Activity("E", 6, 10));
        selectActivity(list);
    }
}
```

```
C B E 
```

### 거스름돈 문제

```java
// 거스름돈 문제

import java.util.HashMap;
import java.util.Map;

public class Main2 {
    public static void getChangeCoins(int receivedMoney, int price) {
        // 동전 종류
        final int[] coins = {500, 100, 50, 10, 5, 1};
        HashMap<Integer, Integer> result = new HashMap<>();

        // 잔돈
        int change = receivedMoney - price;
        int cnt = 0;

        for (int i = 0; i < coins.length; i++) {
            // 동전 단위가 잔돈보다 크면 continue
            if (change < coins[i]) {
                continue;
            }

            // 해당 동전 개수
            int q = change / coins[i];
            result.put(coins[i], result.getOrDefault(coins[i], 0) + q);

            // 남은 잔돈
            change %= coins[i];
            // 거스름돈 동전 개수 업데이트
            cnt += q;
        }

        System.out.println("거스름돈 동전 개수: " + cnt);
        for (Map.Entry<Integer, Integer> cur: result.entrySet()) {
            System.out.println(cur.getKey() + ": " + cur.getValue());
        }
    }

    public static void main(String[] args) {
        // Test code
        getChangeCoins(1000, 100);
        getChangeCoins(1234, 500);
    }
}
```

```
거스름돈 동전 개수: 5
500: 1
100: 4
거스름돈 동전 개수: 10
1: 4
500: 1
100: 2
10: 3
```

출처 : 제로베이스
